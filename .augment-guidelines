# New Employee Landing System - Microservice Context Rules

## Domain-Driven Design Guidelines
- Use ubiquitous language throughout the codebase
- Clearly separate bounded contexts
- Implement entities with proper identity and lifecycle
- Use value objects for descriptive concepts without identity
- Implement domain services for operations that don't belong to entities
- Follow aggregates pattern for transactional consistency

## Clean Architecture Guidelines
- Maintain strict dependency rule: outer layers depend on inner layers
- Domain layer must have no external dependencies
- Use ports (interfaces) in the application layer
- Implement adapters in the infrastructure layer
- Controllers should be thin and delegate to use cases
- Keep business logic in the domain and application layers

## Coding Standards
- ALWAYS use TypeScript, NEVER use JavaScript
- Use TypeScript's strict mode
- Follow SOLID principles
- Implement proper error handling
- Use dependency injection
- Write unit tests for all business logic
- Document public APIs using JSDoc

## Architecture Design
### 1. Overall Microservices Architecture
We’ll decompose by bounded contexts into six core services:
1. **employee-service** – manages profiles & identity
2. **document-service** – handles uploads & review
3. **task-service** – assigns and tracks onboarding tasks
4. **training-service** – schedules sessions & enrollments
5. **department-service** – manages team assignments
6. **notification-service** – dispatches emails/reminders

An **API Gateway** will expose public HTTP endpoints; internal sync calls go via REST, async events via a message broker (e.g. RabbitMQ).

---

### 2. Service Boundaries & Communication
- Each service owns its own PostgreSQL schema.
- **Sync**: REST + JSON over HTTPS (intra-cluster).
- **Async**: Domain events (e.g. `EmployeeCreated`, `DocumentApproved`) via AMQP.
- **API Gateway** handles auth, routing, rate-limit.

---

### 3. Data Models & Schema Sketches

#### employee-service (schema `employee`)
- `employees` (id PK, name, email, start_date, status)

#### document-service (schema `document`)
- `documents` (id PK, employee_id FK, type, url, status, reviewed_at)

#### task-service (schema `task`)
- `tasks` (id PK, employee_id FK, template_id FK, description, due_date, status)

#### training-service (schema `training`)
- `sessions` (id PK, title, starts_at, capacity)
- `enrollments` (id PK, session_id FK, employee_id FK, status)

#### department-service (schema `department`)
- `departments` (id PK, name, manager_id FK)
- `assignments` (id PK, department_id FK, employee_id FK, assigned_at)

#### notification-service (no own DB; reads via events + stores logs)
- `notifications` (id PK, event_type, payload JSON, sent_at)

---

### 4. API Contracts & Documentation Standards
- Each service provides an OpenAPI v3 spec in `/docs/openapi.yaml`.
- Standard endpoints:
  - `GET /<resource>`
  - `GET /<resource>/:id`
  - `POST /<resource>`
  - `PUT /<resource>/:id`
  - `DELETE /<resource>/:id`
- Responses follow JSON:API style.
- All specs published to a shared developer portal (Swagger UI).

---

### 5. Monorepo Folder Structure
```
/ (monorepo root)
├── services/
│   ├── employee-service/
│   ├── document-service/
│   ├── task-service/
│   ├── training-service/
│   ├── department-service/
│   └── notification-service/
├── libs/             # shared DTOs, types, utilities
├── infra/            # AMQP config, API Gateway, CI/CD
├── docs/
│   ├── RequirementsAnalysis.md
│   └── ArchitectureDesign.md
├── .windsurfrules
├── .continuerules
├── .augment-guidelines
├── package.json      # workspace definitions
└── tsconfig.json     # base config + per-service overrides
```


## Code Organization
- Place domain entities in `/src/domain/entities`
- Place value objects in `/src/domain/value-objects`
- Place domain services in `/src/domain/services`
- Place repository interfaces in `/src/domain/repositories`
- Place use cases in `/src/application/use-cases`
- Place controllers in `/src/interface/controllers`
- Place routes in `/src/interface/routes`
- Place database implementations in `/src/infrastructure/database`
- Place external service adapters in `/src/infrastructure/adapters`

## Detailed Service Structure
Each microservice follows a consistent structure based on Clean Architecture principles:

```
service-name/
├── src/
│   ├── domain/
│   │   ├── entities/         # Core business entities
│   │   ├── repositories/     # Repository interfaces
│   │   ├── services/         # Domain services
│   │   └── value-objects/    # Value objects
│   ├── application/
│   │   ├── dtos/             # Data Transfer Objects
│   │   ├── ports/            # Input/Output ports
│   │   └── use-cases/        # Application use cases
│   ├── infrastructure/
│   │   ├── adapters/         # External service adapters
│   │   ├── config/           # Configuration
│   │   └── database/
│   │       ├── migrations/   # Database migrations
│   │       ├── models/       # ORM models
│   │       └── repositories/ # Repository implementations
│   └── interface/
│       ├── controllers/      # API controllers
│       ├── middlewares/      # Express middlewares
│       ├── routes/           # API routes
│       └── validators/       # Request validators
└── tests/
    ├── e2e/                  # End-to-end tests
    ├── integration/          # Integration tests
    └── unit/                 # Unit tests
```

## Naming Conventions
- Use PascalCase for classes and interfaces
- Use camelCase for variables and functions
- Use UPPER_SNAKE_CASE for constants
- Suffix repositories with `Repository`
- Suffix services with `Service`
- Suffix use cases with `UseCase`
- Suffix controllers with `Controller`

## Error Handling
- Create domain-specific error classes
- Use Result pattern for error handling
- Implement global error middleware
- Log errors with appropriate context
- Return consistent error responses

## Database Access
- Use repository pattern for data access
- Implement unit of work pattern for transactions
- Use migrations for schema changes
- Implement data mappers between domain and persistence models

## Business Rules & Workflows

### A. New Employee Registration
1. Employee submits profile → validate mandatory fields → persist.
2. System assigns default "Welcome" task.
- **Rule BR-1:** Email must be unique.
- **Rule BR-2:** Required fields: name, email, start date.

### B. Document Submission & Review
1. Employee uploads doc → status = Pending.
2. HR reviews → Approve/Reject → status updated.
3. On rejection, employee notified to re-upload.
- **Rule BR-3:** Only approved file types.
- **Rule BR-4:** Rejected docs must include rejection reason.

### C. Task Assignment & Tracking
1. HR selects templates → assigns to employee.
2. Employee marks task "Done" → audit-logged.
3. Overdue tasks trigger reminders.
- **Rule BR-5:** Task due date ≥ start date.
- **Rule BR-6:** Cannot complete task before assignment.

### D. Training Scheduling
1. Trainer creates session → sets capacity.
2. Employees enroll → check capacity.
3. Session reminder sent 24 h prior.
- **Rule BR-7:** Enrollment closes 1 h before session.

### E. Department Integration
1. Manager assigns employee → triggers welcome email to team.
2. Employee appears on team dashboard.
- **Rule BR-8:** Only one department per employee at a time.
